<script>
function parseBankPdf(text){
  const lines = text.split(/\n+/).map(s => s.replace(/\u00A0/g,' ').trim()).filter(Boolean);

  // 1) Infer a year from headers (Statement Date / Period / Closing Balance lines)
  let stmtYear = null;
  for (const L of lines) {
    const m = L.match(/\b(20\d{2})\b/);
    if (m) { stmtYear = m[1]; break; }
  }

  // 2) Tokens & helpers
  const mon = {jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12};
  const dayMon = new RegExp("^\\d{1,2}\\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$", "i");
  const fullDate = /^(?:\d{1,2}\s+[A-Za-z]{3}\s+\d{4}|\d{1,2}\/\d{1,2}\/\d{4}|\d{4}-\d{2}-\d{2})$/;

  const toISO = (d,m,y) => `${y}-${String(mon[m.toLowerCase()]).padStart(2,'0')}-${String(d).padStart(2,'0')}`;

  const isAmountLike = s => /^(?:R\s*)?\(?-?\d{1,3}(?:[ ,]\d{3})*|\d+)(?:[.,]\d{2})\)?(?:\s*(?:CR|DR))?$/i.test(s);
  const isNumericMoney = s => /^(?:R\s*)?\(?-?\d{1,3}(?:[ ,]\d{3})*|\d+)(?:[.,]\d{2})\)?$/i.test(s);
  const cleanMoney = s => {
    if(!s) return NaN;
    const neg = /^\(.*\)$/.test(s) || /\bDR\b/i.test(s) || /-\d/.test(s);
    const cr  = /\bCR\b/i.test(s);
    const v = parseFloat(String(s).replace(/[R\s,]/g,'').replace(/(CR|DR)/i,''));
    if (isNaN(v)) return NaN;
    if (cr) return Math.abs(v);
    return neg ? -Math.abs(v) : Math.abs(v);
  };

  // Headers/junk we ignore in description
  const junkStart = /^(date|description|amount|balance|accrued|bank|charges|transactions in rand|page|statement|opening balance|closing balance|service fees|credit rate|debit rate|overdraft limit)$/i;
  const looksRef  = /(\d{3,}\*\d{3,})|([A-Za-z]{2}\d{2}\/\d{2})/; // e.g., 412752*3702 or 07/94

  // 3) Build blocks: start when we see a date token (either "dd Mon" or a full date)
  const blocks = [];
  let cur = null;

  function startBlockByDayMon(L){
    const d = L.split(/\s+/)[0], mo = L.split(/\s+/)[1];
    const y = stmtYear || new Date().getFullYear();
    return { dateISO: toISO(d, mo, y), parts: [], flags: { cr:false, dr:false } };
  }

  for (let i=0;i<lines.length;i++){
    const L = lines[i];

    if (fullDate.test(L)) { if (cur) blocks.push(cur); cur = { dateISO: L, parts: [], flags:{cr:false,dr:false} }; continue; }

    const m = L.match(dayMon);
    if (m) { if (cur) blocks.push(cur); cur = startBlockByDayMon(L); continue; }

    if (!cur) continue; // ignore preamble

    if (/^\s*CR\s*$/i.test(L)) cur.flags.cr = true;
    if (/^\s*DR\s*$/i.test(L)) cur.flags.dr = true;

    cur.parts.push(L);
  }
  if (cur) blocks.push(cur);

  // 4) Parse each block
  const incomeHint = /transfer from|salary|deposit|refund|reversal/i;
  const out = [];

  for (const b of blocks){
    // Scan parts, identify numeric tokens and their surrounding tokens
    const tokens = b.parts.filter(x => x && !junkStart.test(x));
    const numbers = [];
    for (let i=0;i<tokens.length;i++){
      if (isNumericMoney(tokens[i])) {
        const next1 = (tokens[i+1]||'').trim();
        const next2 = (tokens[i+2]||'').trim();
        const hasCrDr = /^\s*(CR|DR)\s*$/i.test(next1) || /^\s*(CR|DR)\s*$/i.test(next2);
        numbers.push({idx:i, raw:tokens[i], val:cleanMoney(tokens[i]), hasCrDr});
      }
    }

    // Choose balance: last number that is followed by CR/DR; otherwise the last number.
    let balIdx = -1;
    for (let k=numbers.length-1;k>=0;k--){
      if (numbers[k].hasCrDr) { balIdx = k; break; }
    }
    if (balIdx === -1 && numbers.length) balIdx = numbers.length-1;

    // Amount is the numeric immediately before balance
    let amtIdx = (balIdx>0) ? balIdx-1 : -1;
    if (amtIdx === -1 && numbers.length) amtIdx = 0;

    const amountVal = (amtIdx>=0 && !isNaN(numbers[amtIdx].val)) ? Math.abs(numbers[amtIdx].val) : NaN;
    if (isNaN(amountVal) || amountVal===0) continue;

    // Build description from everything that isn't an amount/balance/CR/DR token
    const skipIdx = new Set([numbers[amtIdx]?.idx, numbers[balIdx]?.idx, numbers[balIdx]?.idx+1, numbers[balIdx]?.idx+2]);
    const descParts = tokens.filter((t,ix)=>{
      if (skipIdx.has(ix)) return false;
      if (/^\s*(CR|DR)\s*$/i.test(t)) return false;
      if (looksRef.test(t)) return false;
      return true;
    });
    let desc = descParts.join(' ').replace(/\s{2,}/g,' ').trim();
    if (!desc) desc = '(no description)';

    // Decide type
    let type = 'expense';
    if (b.flags.cr || incomeHint.test(desc)) type = 'income';
    // If statement shows DR explicitly near amount line
    if (b.flags.dr && !incomeHint.test(desc)) type = 'expense';

    const renamed = applyRenameRaw(desc);
    const merch = normaliseMerchant(renamed);

    out.push({
      date: b.dateISO,
      type,
      desc: renamed,
      merchant: renamed,
      normMerchant: merch,
      category: autoCategory({merchant: merch, raw: desc}),
      amount: amountVal,
      account: 'Bank',
      src: 'pdf'
    });
  }

  return out;
}
</script>
